[{"content":"记录Ubuntu安装VCS踩的坑\r Ubuntu安装VCS 大部分问题可以通过下面的链接解决。\nUbuntu虚拟机中VCS安装和启动过程中遇到的问题总结_远古架构师alanwu的博客-CSDN博客_启动vcs\n数字IC设计的第一步——Synopsys EDA Tools的安装_WeelCJ的博客-CSDN博客_scl_keygen.exe\nVCS 安装在ubuntu18.04下面的问题\n/bin/sh illegal option -h 或者 (verdi) Syntax error: \u0026ldquo;(\u0026rdquo; unexpected Python成神之路 - VCS-Verdi ubuntu 安装 (iitter.com)\n ubuntu的sh指向dash，删了直接链接到bash\n 1 2  sudo rm -f /bin/sh sudo ln -s /bin/bash /bin/sh   /bin/csh：解释器错误：没有那个文件或目录（/bin/csh: bad interpreter: No such file or dictionary） /bin/csh：解释器错误：没有那个文件或目录（/bin/csh: bad interpreter: No such file or dictionary）ShuqiaoS的博客-CSDN博客/bin/csh: bad interpreter: no such file or directo\n 安装csh\n 1  sudo apt-get install csh   Makefile:109: recipe for target \u0026lsquo;product_timestamp\u0026rsquo; failed  gcc版本降级到4.8。\n 降级可参考Ubuntu20.04.3中安装gcc-4.8.5，gcc多版本共存 - zzoozzoo - 博客园，随便选个其他的源就可以了。\n1  vcs -full64 -cpp g++-4.8 -cc gcc-4.8 -LDFLAGS -Wl,--no-as-needed   libvcsnew.so: undefined reference to \u0026hellip;  gcc版本降级到4.8。\n 参考上一条。\nunrecognized command line option \u0026lsquo;-no-pie\u0026rsquo; Ubuntu虚拟机中VCS安装和启动过程中遇到的问题总结_远古架构师alanwu的博客-CSDN博客_启动vcs\n 进入VCS安装路径对应的/bin/文件夹下，打开vcs文件，将其中的SNPS_VCS_INTERNAL_UBUNTU_PRE_LDFLAGS参数后面的-no-pie删除。可通过grep查找相关位置。\n 1  grep -r \u0026#34;PRE_LDFLAGS\u0026#34;   undefined reference to \u0026lsquo;pthread_yield\u0026rsquo; 求助Ubuntu 22.04 中 VCS 2018.09-SP2遇到undefined reference to `pthread_yield'的错误\n 更新lib名\n 1 2 3 4  #1. 备份 mv O-2018.09-SP2/linux64/lib/vcs_save_restore_new.o O-2018.09-SP2/linux64/lib/vcs_save_restore_new.o.bak #2. 替换符号表中的pthread_yield objcopy --redefine-sym pthread_yield=sched_yield O-2018.09-SP2/linux64/lib/vcs_save_restore_new.o.bak O-2018.09-SP2/linux64/lib/vcs_save_restore_new.o   libtiff.so.3: cannot open shared object file: No such file or directory libtiff.so.3: cannot open shared object file: No such file or directory_PYGC的博客-CSDN博客_libtiff.so.3\n 找不到是因为库比较新，而你的工具所需要的库比较老，在不改变原来库的基础上让使用软连接即可。链接一下\n 1  sudo ln -s /usr/lib/x86_64-linux-gnu/libtiff.so.5 /usr/lib/x86_64-linux-gnu/libtiff.so.3   libmng.so.1: cannot open shared object file: No such file or directory (原创)解决X86_64运行DC时依赖库报错 - 我的FPGA (myfpga.cn)\n 安装一下，链接一下\n 1 2  sudo apt-get install libjpeg62 libmng-dev -y sudo ln -s /usr/lib/x86_64-linux-gnu/libmng.so.2 /usr/lib/x86_64-linux-gnu/libmng.so.1   version `GLIBC_PRIVATE\u0026rsquo; not found (原创)解决X86_64运行DC时依赖库报错 - 我的FPGA (myfpga.cn)\n 在Ubuntu22.04上没有找到办法，退回18.04解决。。\n ","description":"","id":0,"section":"docs","tags":null,"title":"ubuntu22.04/18.04使用VCS","uri":"https://honkw-note.vercel.app/docs/eda/ubuntu_vcs/"},{"content":"记录bash部分命令。来源Linux命令行与shell脚本编程大全（第3版）\r ","description":"","id":1,"section":"docs","tags":null,"title":"bash使用","uri":"https://honkw-note.vercel.app/docs/linux/bash/bash/"},{"content":"记录Ubuntu安装EDA环境遇到的问题\r Ubuntu安装EDA环境 主要参考以下文章：\n搭建属于自己的数字IC EDA环境（一）：安装VMware15.5和centos7及其后面几篇。\n搭建属于自己的数字IC EDA环境（七）：Ubuntu下ASIC/FPGA环境搭建 \nlmgrd: No such file or directory lmgrd遇到lmgrd: No such file or directory_baidu_34971492的博客-CSDN博客\n 安装lsb-core\n 1  apt-get install lsb-core   Can\u0026rsquo;t remove statfile /usr/tmp/.flexlm/lmgrdl.1999: errno No such file or directory 安装Synopsys DC的license时的问题，请高手解答！ - EDA资源使用讨论 - EETOP 创芯网论坛 (原名：电子顶级开发网) -\n 自己新建一个/usr/tmp/.flexlm\n (lmgrd) Failed to open the TCP port number in the license. (lmgrd) Failed to open the TCP port number in the license. - IC验证讨论 - EETOP 创芯网论坛 (原名：电子顶级开发网) -\n 关掉license，过几分钟重试\n 1 2  lmdown lmgrd -c [license地址] #e.g. /home/admin/eda/synopsys/license/synopsys.dat   Can\u0026rsquo;t Install O-2018.09-SP2 release of vcs-mx:SHA256 sum mismatch for file Sentaurus 安装求助 （SHA256 sum mismatch） - EDA资源使用讨论 - EETOP 创芯网论坛 (原名：电子顶级开发网) -\n 原因未知，貌似是百度网盘校验的问题。根据网友提示，重新复制了一遍安装文件重新安装就好了。\n (lmgrd) Please kill, and run lmreread VCS、Verdi license破解遇到的问题和解决的方法 - FPGA/ASIC资料共享 - EETOP 创芯网论坛 (原名：电子顶级开发网) -\n 其实是一些临时文件的冲突：进去提示的目录下，全部删掉那些lmgrd的临时文件\n cd /var/tmp sudo rm lock*  如果想查看lmgrd的启动日志\n 1  lmgrd -c [license地址] -l [log地址] #e.g. /home/admin/eda/synopsys/license/lic.log   Ubuntu开机启动lmgrd 搭建属于自己的数字IC EDA环境（六）：开机自动激活 Synopsys license\nUbuntu 18.04 LTS 配置 rc.local 开机自动启动脚本-老唐笔记 (oldtang.com)\nubuntu-18.04 设置开机启动脚本 - 简书 (jianshu.com)\nubuntu 20.04通过systemd方式增加开机启动 - 1024搜-程序员专属的搜索引擎 (1024sou.com)\n 按照第一个链接写脚本，按照第二个链接弄启动位置的rc.local，按照第三个链接启动rc-local.service就好了。\n如果不对，去lmgrd添加-l，开机查看一下log的具体问题\n 1 2  sudo systemctl start rc-local.service #启动 sudo systemctl status rc-local.service #查看状态   Ubuntu桌面改为Desktop ubuntu修改系統/資料夾語言（中文/英文互轉） - 程式人生 (796t.com)\n 将系统语言改两次，第一次Update Names，第二次Keep Old Names，就可以中文系统下面保持Desktop了\n Failed to load module canberra-gtk-module 解决 Failed to load module canberra-gtk-module__yuki_的博客-CSDN博客_canberra-gtk-module\n 18.04的gvim打开有这个问题，安装一下\n 1  sudo apt-get install libcanberra-gtk-module   其他参考 WSL Ubuntu16.04安装GUI +VCS+Verdi 个人踩坑记录+填坑答疑_努力的卑微小陈的博客-CSDN博客\n从零开始VCS+Verdi 安装过程 (daimajiaoliu.com)\nUbuntu 18.04/16.04 安装破解 VCS 2016/2018 和 Verdi 2016/2018，以及和vivado联合仿真 Ubuntu,VCS,Verdi - 最大最专业的FPGA论坛 (hifpga.com)\n","description":"","id":2,"section":"docs","tags":null,"title":"ubuntu20.04安装EDA","uri":"https://honkw-note.vercel.app/docs/eda/ubuntu/"},{"content":"记录Vim相关的一些插件用法及Vim使用中的问题作为参考文档。\r 插件（Plugin） vim-plug  vim插件管理器\njunegunn/vim-plug: Minimalist Vim Plugin Manager\n 一个Vim插件管理器，利用异步并行可以快速地安装、更新和卸载插件。\n  安装\n:PlugInstall\n  卸载\n:PlugClean\n  升级\n:PlugUpdate\n  列表\n:PlugStatus\n  加速源：\nVIM-Plug安装插件时，频繁更新失败，或报端口443被拒绝 - 知乎 (zhihu.com)\nJust a moment\u0026hellip; (fastgit.org)\nGitHub: Where the world builds software · GitHub (gitfast.tk)\nnerdtree  树形文件管理器\npreservim/nerdtree: A tree explorer plugin for vim.\n   呼出\n:NERDTree\n  vim-visual-star-search  可视模式下通过*搜索\nnelstrom/vim-visual-star-search: Start a * or # search from a visual block (github.com)\n tpope  Tim Pope 大神做的的几个vim必备插件\ntpope/vim-surround: surround.vim: quoting/parenthesizing made simple\ntpope/vim-commentary: commentary.vim: comment stuff out\ntpope/vim-speeddating: speeddating.vim: use CTRL-A/CTRL-X to increment dates, times, and more\ntpope/vim-repeat: repeat.vim: enable repeating supported plugin maps with \u0026ldquo;.\u0026rdquo; \n vim-surround  自动环绕（围绕）\n   新增（）-ys\n假设inner word添加[]\nysiw]\n假设line添加\u0026rsquo;()'\nyss(\n  删除 - ds\n假设删除()\nds{\n  改变 - cs\n  可视模式 - S\nS(\n  vim-commentary  快速注释\n   注释行\ngcc\n  注释对象\ngc+object\n  vim-speeddating  强化\u0026lt;C-A\u0026gt;和\u0026lt;C-X\u0026gt;，支持时间加减\n vim-repeat  使用\u0026rsquo;.\u0026lsquo;重复以上插件的动作\n easymotion  快速移动光标\neasymotion/vim-easymotion: Vim motions on speed!\n 参考vim easymotion 瞬间移动大法[视频] - 知乎\nvim-airline  状态栏美化，且支持另外的多个插件\nvim-airline/vim-airline: lean \u0026amp; mean status/tabline for vim that\u0026rsquo;s light as air\n zoom  通过+和-符号放大缩小Gvim\nvim-scripts/zoom.vim: control gui font size with \u0026ldquo;+\u0026rdquo; or \u0026ldquo;-\u0026rdquo; keys.\n AutoComplPop  比较简单的一个自动补全插件\nvim-scripts/AutoComplPop: Automatically opens popup menu for completions\n load_template  载入模板插件\nvim-scripts/load_template: Loading templates as html,makefile,class \u0026hellip; and you can make template yourself!\n VisIncr  数字列操作\nvim-scripts/VisIncr: Produce increasing/decreasing columns of numbers, dates, or daynames\n ALE  代码检查插件\ndense-analysis/ale: Check syntax in Vim asynchronously and fix files, with Language Server Protocol (LSP) support\n ALE作为verilog的代码检查工具时，外置Linter返回的文本在Windows系统下会存在问题（正则表达式不匹配），需要自行替换其正则表达式。详情可参考：\n dense-analysis/ale: Check syntax in Vim asynchronously and fix files, with Language Server Protocol (LSP) support Fix ghdl and vcom linter regex patterns to support Windows paths (i.e. drive letter and colon C:) by azvanderpas · Pull Request #3346 · dense-analysis/ale  以我的为例(iverilog.vim)：(可能出现的问题语句为C:\\Users\\Honk\\AppData\\Local\\Temp\\VIABCBF.tmp\\PipelineMIPS.v:41: syntax error，原pattern无法匹配)\n1 2  \u0026#34;let l:pattern = \u0026#39;^[^:]\\+:\\(\\d\\+\\): \\(warning\\|error\\|syntax error\\)\\(: \\(.\\+\\)\\)\\?\u0026#39; let l:pattern = \u0026#39;^.\\+:\\(\\d\\+\\): \\(warning\\|error\\|syntax error\\)\\(: \\(.\\+\\)\\)\\?\u0026#39;   tablify  画表格\nstormherz/tablify: Tablify is a VIM plugin that turns simple structured data into nice-looking tables\n DrawIt  画ASCII图\nvim-scripts/DrawIt: Ascii drawing plugin: lines, ellipses, arrows, fills, and more!\n 快捷键（Mapping）  快捷键mapping的各种配置方法\nVim快捷键映射mapping - 知乎 (zhihu.com)\n ","description":"","id":3,"section":"docs","tags":null,"title":"vim使用","uri":"https://honkw-note.vercel.app/docs/linux/vim/gvim/"},{"content":"modelsim/questasim 使用技巧。\r Δcycle 仿真运行的最小单位是Δcycle。\n 默认情况下，时钟对于组合电路的驱动会添加一个无限最小时间 (delta-cycle)的延迟，而该延迟无法用绝对时间单位衡量， 它要比最小时间单位精度还小。 在一个时间片(time-slot)中可以发生很多事情，例如在仿真器中敲入命令run 0，即是让仿真器运行一个 (delta-cycle)的时间。  modelsim使用工具栏的\u0026rsquo;\u0026rsquo;expanded time deltas mode\u0026quot;, 选中\u0026rsquo;\u0026rsquo;expanded time at active cursor\u0026quot;查看Δcycle\n","description":"","id":4,"section":"docs","tags":null,"title":"questasim","uri":"https://honkw-note.vercel.app/docs/verification/questasim/questasim/"},{"content":"systemverilog笔记。\r datatype-数据类型 普通变量-var   默认变量\n\r\r默认var logic\r\r1 2 3  var logic [63:0] addr; logic [63:0] addr; wire logic [63:0] addr;   \r\r   2值/4值逻辑\n\r\r2-value vs 4-value\r\r   4-value (default x) 2-value (default 0)     integer int   logic bit   reg,wire,tri(net-type) byte,shortint,longint    \r   有符号 vs 无符号\n\r\rsigned vs unsigned\r\r   signed unsigned     integer logic   int bit   byte,shortint,longint reg,wire,tri(net-type)    \r   shortreal = float , real = double\n  枚举-enum   enum如果二值可以赋0或1，如果四值可以赋x或z\n\r\renum\r\r1 2  enum bit {TRUE,FALSE} Boolean; enum {WAIT,LOAD,READY} state_t;\t//int   \r\r   枚举类型可以赋值整型，整型不能赋值枚举类型\n  自定义-typedef   enum，struct建议使用typedef\n\r\rtypedef\r\r1 2 3  struct { int a, b; // 32-bit variables } Instruction_Word;   1 2 3 4  typedef struct { // structure definition logic [31:0] a, b; } instruction_word_t; instruction_word_t IW; // structure allocation   \r\r   取值 ，赋初始值\n\r\rvalue assign\r\r1 2 3 4  IW.a = 100; // reference structure member IW.b = 5; IW = \u0026#39;{100, 3};\t//initialize   \r\r   字符串-string   string存储单元为byte类型\n\r\rstring byte\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  typedef logic [15:0] r_t; r_t r; integer i = 1; string b = \u0026#34;\u0026#34;; string a = {\u0026#34;Hi\u0026#34;, b}; r = r_t\u0026#39;(a); // OK b = string\u0026#39;(r); // OK b = \u0026#34;Hi\u0026#34;; // OK b = {5{\u0026#34;Hi\u0026#34;}}; // OK a = {i{\u0026#34;Hi\u0026#34;}}; // OK (non-constant replication) a = {i{b}}; // OK a = {a,b}; // OK a = {\u0026#34;Hi\u0026#34;,b}; // OK b = {\u0026#34;H\u0026#34;,\u0026#34;\u0026#34;}; // yields \u0026#34;H\u0026#34;. \u0026#34;\u0026#34; is the empty string a[0] = \u0026#34;h\u0026#34;; // OK, same as a[0] = \u0026#34;cough\u0026#34;   \r\r   方法\n\r\rmethod\r\r1 2 3 4 5 6 7  str.len()\t//返回字符串的长度。 str.putc(i, c)\t//将第i个字符替换为字符c，等同于str[i]=c。 str.getc(i)\t//返回第i个字符。 str.substr(i, j)\t//将从第i个字符到第j个字符的字符串返回。 str.{atoi(), atohex(), atooct, atobin}\t//将字符串转变为十进制、十六进制、八进制或者二进制数据。 str = \u0026#34;123\u0026#34;; int i = str.atoi(); // assigns 123 to i.   \r\r   类型转换  显示转换  静态转换 'int 'real 动态转换 $cast(tgt,src)   隐式转换  logic -\u0026gt;bit x -\u0026gt; 0    design-可综合设计优化 \r\rnew design\r\r  添加接口（interface）从而将通信和协议检查进一步封装。\n  添加类似C语言的数据类型，例如int、byte。\n  添加用户自定义类型，枚举类型，结构体类型。\n  添加类型转换（$cast(T, S)或者’()）。\n  添加包（package）从而使得多个设计之间可以共享公共类型和方法。\n  添加方便的赋值操作符和运算操作符，例如++、+=、===。\n  \r always 添加always_comb、always_latch和always_ff等过程语句块。\n  always_comb() 和 always@(*)的区别\nalways_comb() 可以推断function内的敏感列表，always@(*)不行\n\r\ralways_comb\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  always @* begin //infers @(data)  a1 = data \u0026lt;\u0026lt; 1; b1 = decode(); ... end always_comb begin //infers @(data, sel, c, d, e)  a1 = data \u0026lt;\u0026lt; 1; b1 = decode(); ... end function decode; begin case (sel) 2\u0026#39;b01: decode = d | e; 2\u0026#39;b10: decode = d \u0026amp; e; default: decode = c; endcase end endfunction   \r\r   always_latch + always_ff@()替代always@()\n  \u0026lsquo;0,\u0026lsquo;1,\u0026lsquo;x,\u0026lsquo;z SV可以通过'0，'1，'z和'x来分别填充0，1，z和x。\n==? SV在比较数据时，可以通过==?来进行通配比较。在比较操作符的右侧操作数，如果在某些位置有X或者Z，那么它表示的是在该位置上会与左侧操作数的相同位置的任何值相匹配。(匹配x和z)\n\r\r==\r\r\r inside inside可替代多个或逻辑。\n\r\rinside\r\r1 2 3 4  logic [2:0] a; if ( (a==3\u0026#39;b001) || (a==3\u0026#39;b010) || (a==3\u0026#39;b100) )... =\u0026gt; if ( a inside {3\u0026#39;b001, 3\u0026#39;b010, 3\u0026#39;b100} )...   \r\r case   priority case\npriority case表示必须至少有一个case选项满足要求。priority case的逻辑同if..else的逻辑一致。\n\r\rpriority\r\r1 2 3  priority case (\u0026lt;case_expression\u0026gt;) ... // case items endcase   \r\r   unique case\nunique case可以并行执行，且case选项必须完备\n\r\runique\r\r1 2 3  unique case (\u0026lt;case_expression\u0026gt;) ... // case items endcase   \r\r   ","description":"","id":5,"section":"docs","tags":null,"title":"week2 数据类型,可综合设计","uri":"https://honkw-note.vercel.app/docs/verification/sv/wekk2/"},{"content":"learn-vimscript-the-hard-way\n","description":"","id":6,"section":"docs","tags":null,"title":"vimscript","uri":"https://honkw-note.vercel.app/docs/linux/vim/learn-vimscript-the-hard-way/"},{"content":"正则表达式\n","description":"","id":7,"section":"docs","tags":null,"title":"regex","uri":"https://honkw-note.vercel.app/docs/linux/regex/"},{"content":"流文本编辑器\n","description":"","id":8,"section":"docs","tags":null,"title":"sed使用","uri":"https://honkw-note.vercel.app/docs/linux/bash/sed/"},{"content":"systemverilog笔记。\r interface-接口   声明、例化、modport、索引\n\r\rdeclare\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  interface main_bus; wire [15:0] data; wire [15:0] address; logic [7:0] slaveinstruction; logic slave_request; logic bus_grant; logic bus_request; logic slave_ready; logic data_ready; logic mem_read; logic mem_write; endinterface interface main_bus (input logic clock, resetN, test_mode); wire [15:0] data; wire [15:0] address; logic [7:0] slaveinstruction; logic slave_request; logic bus_grant; logic bus_request; logic slave_ready; logic data_ready; logic mem_read; logic mem_write; endinterface   \r\r \r\rinst\r\r1 2 3 4 5 6 7 8 9  main_bus bus (); // instance of an interface  main_bus bus ( // instance of an interface .clock(clock), .resetN(resetN}, .test_mode(test_mode) ); main_bus bus(clock,resetN,test_mode);   \r\r \r\rmodport\r\r不同模块看到同一组信号的连接方向。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  interface chip_bus (input logic clock, resetN); logic interrupt_request, grant, ready; logic [31:0] address; wire [63:0] data; modport master (input interrupt_request, input address, output grant, ready, inout data, input clock, resetN); modport slave (output interrupt_request, output address, input grant, ready, inout data, input clock, resetN); endinterface   \r\r \r\rindex\r\r1 2 3  always @(posedge bus.clock, negedge bus.resetN) primary i1 (bus.master); secondary i2 (bus.slave);   \r\r   interface 与 struct 的区别\n例化的区别、结构的区别\u0026hellip;\n  interface 与 module 的关系\n接口类似模块，但级别稍低。\n 模块(module)可以例化模块(module)，模块(module)可以例化接口(interface) 接口(interface)可以例化接口(interface)，接口(interface)不能例化模块(module)    interface 中可以定义\n参数（parameter），输入输出端口（input,output），函数和任务（fucntion,task），过程语句块（always，initial）\n  clocking clocking一般在interface中使用，用于数据驱动和数据采样\n\r\rclocking\r\r1 2 3 4 5 6 7  clocking bus @(posedge clock1); default input #10ns output #2ns; //if no setting,  //default sample #1step, drive #0(infinite delta cycle) after sample  input data,ready,enable; //normal sample  output negedge ack; //negedge drive ack  input #1step addr; //1step before posedge clock1 endclocking    clocking bus @(posedge clock1);，时钟块默认上升沿驱动 default input #10ns output #2ns; ，默认采样输入提前10ns，驱动输出滞后2ns output negedge ack;，ack信号下降沿驱动（覆盖默认） input #1step addr;，addr信号 #1step提前采样（覆盖默认）  可以有多个clocking，信号在不同clocking中的方向可以不同（可以在测试平台既作为采样输入，有作为驱动输出）\n\r ","description":"","id":9,"section":"docs","tags":null,"title":"week3 接口","uri":"https://honkw-note.vercel.app/docs/verification/sv/week3/"},{"content":"systemverilog笔记。\r enviroment-验证环境   激励发生器-stimulator\n 发起器-initiator 响应器-responder    监测器-monitor\n观察内部信号尽量少\n  比较器 -checker\n 参考模型 - reference model(predictor) 数据比较  线上比较（online check） 线下比较（offline check）      task\u0026amp;function-任务\u0026amp;函数   task和function区别\n function不会消耗仿真时间，而task则可能会消耗仿真时间。 function无法调用task，而task可以调用function。 一个可以返回数据的function只能返回一个单一数值，而任务或者void function不会返回数值。 task 没有 void    一个可以返回数据的function可以作为一个表达式中的操作数，而该操作数的值即function的返回值。（隐式返回）\n1 2 3  function [15:0] myfunc1(input [7:0] x,y); myfunc1 = x * y -1; //implicit return endfunction     如果调用具有返回值的函数，但是又不使用该返回值时，建议为其添加void’()进行转换。\n1  void\u0026#39;(some_function());     function 声明带返回类型（默认logic），端口默认logic，默认input。返回值有隐式(implicit)和显式(explicit)两种方式。\n\r\rimplicit func vs explicit func\r\r1 2 3 4 5 6 7 8 9 10 11  function [15:0] myfunc1(input [7:0] x,y); myfunc1 = x * y -1; //implicit declaration endfunction function [15:0] myfunc2(input [7:0] x,y); return x * y -1; //explicit declaration endfunction function automatic void myfunc3(input [7:0] x, input [7:0] y, output [15:0] z); z = x * y -1; endfunction   \r\r task task不带返回值，也没有void。task里面可以用return。\n\r\rtask\r\r1 2 3 4 5 6 7 8 9 10 11 12 13  task mytask(input [7:0] x, input [7:0] y, output [15:0] z); #5ns; z = x * y -1; #5ns; endtask task automatic mytask2 ( input [7:0] x, input [7:0] y, ref [15:0] z); z = x * y -1; endtask   \r\r 参数传递   默认值\n可以传递默认值，也可以调用绑定。\n\r\rpass\r\r1 2 3 4 5 6 7 8 9 10 11  function int fun( int j = 1, string s = \u0026#34;no\u0026#34; ); ... endfunction fun( .j(2), .s(\u0026#34;yes\u0026#34;) ); // fun( 2, \u0026#34;yes\u0026#34; ); fun( .s(\u0026#34;yes\u0026#34;) ); // fun( 1, \u0026#34;yes\u0026#34; ); fun( , \u0026#34;yes\u0026#34; ); // fun( 1, \u0026#34;yes\u0026#34; ); fun( .j(2) ); // fun( 2, \u0026#34;no\u0026#34; ); fun( .s(\u0026#34;yes\u0026#34;), .j(2) ); // fun( 2, \u0026#34;yes\u0026#34; ); fun( .s(), .j() ); // fun( 1, \u0026#34;no\u0026#34; ); fun( 2 ); // fun( 2, \u0026#34;no\u0026#34; ); fun( ); // fun   \r\r   ref\n ref参数在传递时不会发生值拷贝，而是将变量“指针”传递到方法中，在方法内部对该参数的操作将会同时影响外部变量。 任务和函数只在调用瞬间传递当前值，而不会检测信号的变化，因此需要ref 典型的在于传递数组参数，直接传递会copy一份，而使用ref则会传递该数组指针并处理该数组。    ","description":"","id":11,"section":"docs","tags":null,"title":"week4 验证环境，任务\u0026函数","uri":"https://honkw-note.vercel.app/docs/verification/sv/week4/"},{"content":"systemverilog笔记。\r array-定长数组   unpacked和packed\n\r\runpacked vs packed \r verilog默认向量为组合型数组(packed)，数组为非组合型数组(unpacked)。（struct默认为非组合型(unpacked)）  1 2  wire [3:0] select;\t//vector packed reg [63:0] data;   1 2  reg [15:0] RAM [0:4095]; //memory array unpacked wire [7:0] table [3:0];    sv允许组合型数组(packed)  1 2 3 4  int a1[7:0][1023:0]; int a2[1:8][1:1024]; logic [31:0] data [1024]; logic [31:0] data [0:1023];   1  logic [3:0][7:0] data; //2-D packed array    \r   2值与4值逻辑变量占用存储的大小不同。\n\r\r2-value vs 4-value\r\r1 2 3 4 5  logic [3:0][7:0] data; //2WORD 64bit 4-value double storage bit [3:0][7:0] data2; //1WORD 32bit 2-value one storage  int arr1[7:0][3:0]; //32WORD integer arr2[7:0][3:0]; //64WORD   \r\r   级别外部先右后左，内部从左往右算\n\r\rarray level\r\r1 2 3  int [1:0][2:0] arr[3:0][4:0]; //4*5*2*3 //highest level arr[3][4][1][2];   \r\r   组合型(packed)数组可以不同维度拷贝，尺寸不同时自动扩展或截位。非组合型(unpacked)数组必须同纬度同尺寸拷贝。\n  初始化、循环、系统函数\n\r\rmethod\r\r  initialization\n  unpacked\n1 2 3 4  int a1 [0:7][0:1023] = \u0026#39;{default:8\u0026#39;h55}; byte a [0:3][0:3]; a[1][0] = 8\u0026#39;h5; // assign to one element a[3] = \u0026#39;{\u0026#39;hF, \u0026#39;hA, \u0026#39;hC, \u0026#39;hE}; // assign list of values to slice of the array     packed\n1 2 3 4 5 6  logic [1:0][1:0][7:0] a; // 3-D packed array a[1][1][0] = 1\u0026#39;b0; // assign to one bit a = 32\u0026#39;hF1A3C5E7; // assign to full array a[1][0][3:0] = 4\u0026#39;hF; // assign to a part select a[0] = 16\u0026#39;hFACE; // assign to a slice a = {16\u0026#39;bz, 16\u0026#39;b0}; // assign concatenation       foreach\n1 2 3 4 5  int sum [1:8] [1:3]; foreach ( sum[i,j] ) sum[i][j] = i + j; // initialize array foreach ( sum[i] ) ...     system function $\n1 2 3 4 5 6  $dimensions();\t//return dimensions of arrary $left(,2); //$left(array,dimenssion), left index of specific dimenssion \t//also $right,$low,$high $size(,1) //$size(array,dimenssion) $increment(,1) //$increment(array,dimenssion) $bits()\t//bits storage of array     \r   dynamic array-动态数组 动态数组为非组合型数组。\n 初始化、循环、删除  \r\rmethod\r\r.delete() , .size()\n1 2 3 4  int dyn[]; initial begin dyn = new[5]; end   1 2 3 4 5 6 7 8 9 10 11 12 13  int dyn[] , d2[]; //default 0 2-bit logic  initial begin dyn = new[5]; foreach (dyn[j]) dyn[j] = j; d2 = dyn; d2[0] = 5; $display(dyn[0],d2[0]); //dyn[0] =? dyn[0] = 0  dyn = new[20](dyn); //allocate 20 ints \u0026amp;\u0026amp; copy  dyn = new[100]; dyn.delete();\t//or dyn = \u0026#39;{}  //or dyn = new[0] end   \r\r queue-队列 队列为组合型数组。\n  初始化、方法\n\r\rmethod\r\r1 2  q2[$] = {3,4}, q[$] = {3,4};   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  q.insert(1,j); q = {q[0],j,q[:$]}; //q.insert(1,j) q = {q[0:2],q2,q[3:$]}; //insert q might not work  q.delete(1);\t//index start from 0  q.push_front(6); q = {6,q}; q = q[0:$-1]; j = q.pop_back(); j = q.pop_back; q = {q,8}; j = q.push_back(8); q = [1,$] j = q.pop_front(); j = q.pop_front; q = {} q.delete() //delete all   \r\r   linked array-关联数组 hash，dictionary\n  初始化、方法\n\r\rmethod\r\r1  bit [31:0] mem[int unsigned];xxxxxxxxxx bit [31:0] mem[int unsigned];   1 2 3 4 5 6 7 8 9 10  //foreach loop foreach(mem[idx])begin $display(\u0026#34;FOREACH_LOOP mem address:\u0026#39;h%0x,data:\u0026#39;h%0x\u0026#34;,idx,mem[idx]); end //first-next loop if(mem.first(addr))begin do $display(\u0026#34;FIRST_NEXT_LOOP mem address:\u0026#39;h%0x,data:\u0026#39;h%0x\u0026#34;,addr,mem[addr]); while(mem.next(addr)); end   \r\r   array method-公有方法 \r\rmethod\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  .size(); .sum(); .product(); .or(); .and(); .xor(); .min() .max() .unique() .find with (item \u0026gt;3) .find_index with (item==8); .find_last with (); .find_last_index with (); .reverse(); .sort(); .rsort(); .shuffle();   此类方法在动态数组（dynamic array），队列（queue）及关联数组（linked array）内建，定长数组（array）应使用系统函数（其他的也可使用系统函数）。\n\r struct-结构体 结构体为非组合型数组\n","description":"","id":13,"section":"docs","tags":null,"title":"week5 数组","uri":"https://honkw-note.vercel.app/docs/verification/sv/week5/"},{"content":"systemverilog笔记。\r class encapsulation-类的封装   类（class）：包含成员变量+成员方法\n  对象（object）：类在例化后的实例\n  句柄（handle）：指向对象的指针\n  原型（prototype）：程序的声明部分，包含程序名、返回类型和参数列表\n  类的成员（变量/方法）默认都是动态（automatic）生命周期，即每一个对象的变量和方法都会为其开辟新的空间。\n\r\rexample\r\r1 2 3 4 5 6 7 8 9  //data in class are all dynamic by default class Packet;\t//class  integer command;\t//member data  function new();\t//member method  command = IDLE; endfunction endclass Packet p;\t//handle p = new();\t//object   \r\r   static-静态成员（变量/方法）   对象必须在仿真以后（initial）才能创建(new)。\n  静态变量可以理解为属于类，开辟在另一个单独的空间，不与对象开辟的空间在一起。\n  访问方法为class_name::static_data或者object.static_data。\n\r\rexample\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class packet_c1; integer command; packet_c1 prv; static int data = 1; function new(int inival); command = inival; endfunction endclass packet_c1 c1,c2; initial begin:ini_proc $display(\u0026#34;packet_c1 static data is %0d\u0026#34;, packet_c1::data); //data is not in object, the handle is null, but use share area of static data  $display(\u0026#34;c1.data=%0d,c2.data=%0d\u0026#34;, c1.data,c2.data); c1 = new(); $display(\u0026#34;c1.command = %0d\u0026#34;,c1.comand); c2 = c1; $display(\u0026#34;c2.command = %0d\u0026#34;,c2.comand); end   \r\r   this-当前所在对象成员（变量/参数/方法）   systemverilog搜索变量域的方式遵循由近及远。\n\r\rexample\r\r1 2 3 4 5 6 7 8 9  class Demo; integer x; //1  function new(integer x); //2  //no \u0026#34;this\u0026#34;, variable search from near to far  //3 -\u0026gt; 2 -\u0026gt; 1  int x; //3  this.x = x; //point to current class data 1  endfunction endclass   \r\r   shallow copy-浅拷贝   只拷贝成员变量及方法，若成员变量为句柄，则只拷贝句柄，不创建新的句柄指向新的对象（对应deep copy-深拷贝，systemverilog无法完成，必须手动）。\n\r\rexample\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class packet_c1; integer command; packet_c1 prv; static int data = 1; function new(int inival); command = inival; endfunction endclass module tb4; packet_c1 linked_list[$],linked_list2[$]; initial begin packet_c1 cur,new_obj; for(int i=1; i\u0026lt;=10; i++)begin cur = new(i); if(linked_list.size()\u0026gt;0)begin cur.prv = linked_list[$]; end linked_list.push_back(cur); new_obj = new cur; linked_list2.push_back(new_obj); end end endmodule   \r\r   local \u0026amp; protected - 数据隐藏   类的成员（变量/方法）默认情况下，即是公共属性(public)的。这表示对于类自身和外部均可以访问该成员。\n  对于成员的限定，如果使用protected，则表示该类和其子类均可以访问此成员，而外部无法访问。\n  对于成员的限定，如果使用local，则只有该类可以访问此成员，而子类或者外部均无法访问。\n\r\rexample\r\r1 2 3 4 5 6  class Packet; local integer i; function integer compare (Packet other); compare = (this.i == other.i); endfunction endclass   \r\r   package-包   包、库和类的包含关系：library-\u0026gt;package-\u0026gt;class\n  仿真时，为什么在tb内不能直接识别外部声明的package中的类，却可以例化一个外部声明的模块？\n默认编译时，会查找所有的library，module和package都在library内，但\n 如果不指定，默认package不会搜索（因为类隐藏在其内部）。 如果不指定，默认module全部搜索。    package添加   不import添加package的可以直接通过包名索引变量\n\r\rexample\r\r1  $display(\u0026#34;pkg_a::va = %0d, pkg_b::vb = %d\u0026#34;,pkg_a::va,pkg_b::vb);   \r\r   import部分package\n直接将package里对应的变量、类等内容放入当前环境。\n\r\rexample\r\r1 2  import pkg_a::packet_a; import pkg_a::va;   \r\r   import *\nimport package::*，对于所有package的内容，如果没有才import。\n*并不是将package里的内容倒出来，而是找不到相关时，尝试去找，找到即止。查找当前环境是否有对应的变量、类等声明，若有，则不进行import，否则import package里对应的变量、类等内容放入当前环境，package与当前环境不会出现类型冲突。\n\r\rexample\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  package pkg_a; class packet_a; int pkg_a; endclass typedef struct { int data=1; int command; } struct_a; int va = 1; int shared = 10; endpackage module tb; typedef struct { int data=3; int command; } struct_a; import pkg_a::*; initial begin struct_a sta; $display(\u0026#34;sta = %0d\u0026#34;,sta.data);\t//no warning, and sta.data = 3,not 1.never import  end endmodule   \r\r   package内的变量   在同一个环境的两个package不能使用同名变量，必须明确包名。\n  设计package时尽量不要重名，可以添加包名作为前缀。\n\r\rexample\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66  package pkg_a; class packet_a; int pkg_a; endclass typedef struct { int data=1; int command; } struct_a; int va = 1; int shared = 10; endpackage package pkg_b; class packet_b; endclass typedef struct { int data; int command; } struct_b; int vb = 2; int shared = 20; endpackage module mod_a; endmodule module mod_b; endmodule module tb; class packet_tb; endclass //typedef struct {  // int data=3;  // int command;  //} struct_a;  typedef struct { int data=2; int command; } struct_tb; //import pkg_a::packet_a;  //import pkg_b::packet_b;  //import pkg_a::va;  //import pkg_a::vb;  import pkg_a::*; import pkg_b::*; initial begin packet_a pa = new(); packet_b pb = new(); packet_tb ptb = new(); struct_a sta; $display(\u0026#34;sta = %0d\u0026#34;,sta.data); //$display(\u0026#34;pkg_a::va = %0d, pkg_b::vb = %d\u0026#34;,pkg_a::va,pkg_b::vb);  $display(\u0026#34;va = %0d, vb = %d\u0026#34;,va,vb); $display(\u0026#34;shared = %0d\u0026#34;,pkg_a::shared); end endmodule   \r\r   ","description":"","id":14,"section":"docs","tags":null,"title":"week6 类的封装","uri":"https://honkw-note.vercel.app/docs/verification/sv/week6/"},{"content":"systemverilog笔记。\r class inheritance - 类的继承 子类继承父类的成员变量和方法。\n子类/父类句柄调用变量/方法  子类句柄（指向子类对象）调用父类    变量\n  同名\n覆盖，父类变量在子类中可以通过super访问\n  不同名\n继承，父类、子类变量各自独立\n    方法\n  同名\n包括两类，构造函数和和其他方法：\n  构造函数new方法\n系统默认，子类会自动调用父类的new方法，因此：\n  如果父类的new没有参数，那么子类可以添加参数并覆盖。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Packet; integer i = 1; function new(); i = 2; endfunction endclass class LinkedPacket extends Packet; integer i = 3; integer k = 5; function new(int val); super.new(); if(val \u0026gt;= 2) i = val; endfunction endclass     如果父类的new有参数，那么子类必须显式的添加参数（super.new(parameter)），否则继承失败。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Packet; integer i = 1; function new(int val); i = val + 1; endfunction endclass class LinkedPacket extends Packet; integer i = 3; integer k = 5; function new(int val); super.new(val); if(val \u0026gt;= 2) i = val; endfunction endclass       其他方法\n覆盖，父类方法在子类中可以通过super访问\n    不同名\n继承，父类、子类方法各自独立\n    父类句柄（指向父类对象）调用子类    变量\n父类句柄访问子类变量，无法确定其子类，所以无法访问。此时必须进行句柄类型转换。\n  方法\n父类句柄访问子类方法，无法确定其子类，所以无法访问。此时必须进行句柄类型转换。\n  注意，子类对象访问父类变量：子类对象无法访问父类同名变量（.super不能作用于句柄），可以访问不同名的继承变量\n子类/父类句柄赋值   子类句柄赋给父类句柄\n父类句柄（句柄类型不变）指向子类对象（子类句柄指向的对象），作用域只有父类。\n  不同名\n 作用域只有父类    同名\n  变量\n无法动态调用同名子类变量。\n  方法\n通过虚方法动态调用同名子类方法。（超越作用域的范围）\n      父类句柄赋给子类句柄\n子类句柄指向父类对象，编译报错（静态转换），此时需要进行句柄类型动态转换（$cast()），扩大父类句柄的作用域。\n  \r\rexample\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  class Packet; integer i = 1; function new(int val); //i = 2;  i = val + 1; endfunction function shift(); i = i \u0026lt;\u0026lt; 1; endfunction endclass class LinkedPacket extends Packet; integer i = 3; integer k = 5; function new(int val); super.new(val); if(val \u0026gt;= 2) i = val; endfunction function shift(); //super.shift();  i = i \u0026lt;\u0026lt; 2; endfunction endclass module tb; initial begin Packet p = new(3); Packet tmp; LinkedPacket lp = new(1); tmp = lp; $display(\u0026#34;p.i = %0d\u0026#34;, p.i); //i=1 -\u0026gt; i=2  $display(\u0026#34;lp.i = %0d\u0026#34;, lp.i); //child class i =3, parent class i =2  //$display(\u0026#34;lp.super.i = %0d\u0026#34;, lp.super.i); //error  $display(\u0026#34;tmp.i = %0d\u0026#34;, tmp.i); //$display(\u0026#34;tmp.k = %0d\u0026#34;, tmp.k); //error, father cannot access child variable  //p.shift();  //$display(\u0026#34;p shift = %0d\u0026#34;, p.i);  lp.shift(); $display(\u0026#34;lp shift = %0d\u0026#34;, lp.i); end endmodule   \r\r ","description":"","id":15,"section":"docs","tags":null,"title":"week7 类的继承","uri":"https://honkw-note.vercel.app/docs/verification/sv/week7/"},{"content":"randomize-随机化 简单的随机数   verilog中可以通过系统函数$random()%n,$urandom()%n,urandom_range(MAX,MIN)产生\n  系统函数std::randomize()\n结构体随机化（内部必须声明rand），不能使用.randomize。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  typedef struct { rand bit [31:0] src; rand bit [31:0] dst; rand bit [31:0] data[4]; rand bit [ 7:0] kind; } packet_t; module tb2; packet_t pkt; initial begin $display(\u0026#34;before randomized packet src is %0d\\ndst is %0d\\nkind is %0d\\ndata is %p\u0026#34;,pkt.src,pkt.dst,pkt.kind,pkt.data); std:randomize(pkt) with { pkt.src\u0026gt;10; pkt.src\u0026lt;15; }; $display(\u0026#34;after randomized packet src is %0d\\ndst is %0d\\nkind is %0d\\ndata is %p\u0026#34;,pkt.src,pkt.dst,pkt.kind,pkt.data); end endmodules     随机化字符串？\n  实数无法随机化\n  rand/randc   rand/randc(rand cycle)\n定长数组、动态数组、关联数组和队列都可以声明为rand/randc，可以对动态数组和队列的长度加以约束。\n句柄也可以随机化，随机时会随机其内部的变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class packet; rand bit [31:0] src,dst,data[4]; rand bit [7:0] kind; constraint cstr{ src \u0026gt; 10; src \u0026lt; 15; } function print(); $display(\u0026#34;src is %0d\\ndst is %0d\\nkind is %0d\\ndata is %p\u0026#34;,src,dst,kind,data); endfunction endclass module tb; packet p; initial begin p = new(); $display(\u0026#34;before randomize\u0026#34;); p.print(); $display(\u0026#34;after randomize\u0026#34;); p.randomize(); p.print(); end endmodule     类中的结构体，句柄的随机化?\n注意给类中的结构体和句柄加rand\n  随机种子\n-sv_seed n（n为任意整数）\n  constraint-约束 普通约束  \u0026gt;，\u0026lt;，== inside约束  1 2 3 4 5 6 7  rand integer x, y, z; constraint c1 {x inside {3, 5, [9:15], [24:32], [y:2*y], z};} rand integer a, b, c; constraint c2 {a inside {b, c};} integer fives[4] = \u0026#39;{ 5, 10, 15, 20 }; rand integer v; constraint c3 { v inside {fives}; }     unique-去重约束\n1 2 3 4 5 6  //a[2],a[3],b和excluded在随机化之后将包含不相同的数值。 rand byte a[5]; rand byte b; rand byte excluded; constraint u { unique {b, a[2:3], excluded}; } constraint exclusion { excluded == 5; }     dist-权重约束\n :=均等权重 :/平分权重    if-条件约束\n  -\u0026gt;\n1 2  bit [3:0] a, b; constraint c { (a == 0) -\u0026gt; (b == 1); }     if\n1 2 3 4 5 6  constraint c { if (mode == little) len \u0026lt; 10; else if (mode == big) len \u0026gt; 100; }       foreach-循环约束\n不规定size的数组约束会存在问题，questasim和vcs随机化结果不同，questasim为0，vcs可以随机。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  module tb6; class packet; rand byte arry[]; constraint cstr{ foreach(arry[i]) arry[i] inside {2,4,8,16}; foreach(arry[i]) arry[i] \u0026gt; 2*i; arry.size() \u0026lt; 10; } endclass packet p; initial begin p = new(); repeat(10)begin if(p.randomize()) $display(\u0026#34;arry.size==%0d,data is %p\u0026#34;,p.arry.size(),p.arry); else $error(\u0026#34;randomize error\u0026#34;); end end endmodule     约束可以调用函数\n  软约束   子类硬约束自动覆盖父类同名硬约束，如果不同名存在，则均有效。\n  软约束采取就近的原则。\nwith {} constraint -\u0026gt; child soft constraint -\u0026gt; father soft constraint。下面代码最后约束为[21:25]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  module tb7; class packet_a; rand int length; constraint cstr1{soft length inside {[5:15]}; } endclass class packet_b extends packet_a; constraint cstr2{soft length inside {[16:20]}; } endclass initial begin packet_b p = new(); p = new(); repeat(100)begin if(p.randomize() with {soft length inside {[21:25]};}) $display(\u0026#34;p.length==%0d\u0026#34;,p.length); else $error(\u0026#34;randomize error\u0026#34;); end end endmodule     指定随机 默认randomize()随机所有rand变量，但可以指定随机的变量，其他变量不随机。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  module tb8; class simplesum; rand bit [7:0] x,y; bit [8:0] z; constraint cstr { z==x+y; } endclass initial begin simplesum ss = new(); repeat(100)begin //if(ss.randomize(x,y,z)) $display(\u0026#34;x==%d,y=%d,z=%d\u0026#34;,ss.x,ss.y,ss.z);  //if(ss.randomize(z)) $display(\u0026#34;x==%d,y=%d,z=%d\u0026#34;,ss.x,ss.y,ss.z);  if(ss.randomize(x,y)) $display(\u0026#34;x==%d,y=%d,z=%d\u0026#34;,ss.x,ss.y,ss.z); //if(ss.randomize()) $display(\u0026#34;x==%d,y=%d,z=%d\u0026#34;,ss.x,ss.y,ss.z);  else $error(\u0026#34;randomize error\u0026#34;); end end endmodule   内嵌约束 with {}\n内嵌约束指向其randomize的对象。\n1 2 3 4 5 6 7 8 9 10 11  class C1; rand integer x; endclass class C2; integer x; integer y; task doit(C1 f, integer x, integer z); int result; result = f.randomize() with {x \u0026lt; y + z;};\t//x point to C1 randomize object  endtask endclass   使用local和this明确指向。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  module tb9; class packet1; rand bit[7:0] x; constraint cstr {soft x == 5; } endclass class packet2; bit [7:0] x = 10; function int get_rand_x(input bit[7:0] x = 20); packet1 pkt = new(); $display(\u0026#34;this.x==%0d\u0026#34;,this.x);\t//x = 10  $display(\u0026#34;input x==%0d\u0026#34;,x);\t//x = 30  //pkt.randomize with {x == local::this.x;};\t//x = 10  //pkt.randomize with {x == local::x;};\t//x = 30(overwrite 20)  pkt.randomize with {x == x;};\t//x = 5  return pkt.x; endfunction endclass initial begin packet2 pkt = new(); $display(\u0026#34;pkt.x = %0d\u0026#34;,pkt.get_rand_x(30)); end endmodule   随机控制 rand_mode 开关随机化。与指定随机达到一样的效果。\n1 2 3 4 5 6 7 8 9 10 11 12  class Packet; rand integer source_value, dest_value; ... other declarations endclass int ret; Packet packet_a = new; // Turn off all variables in object packet_a.rand_mode(0); // ... other code // Enable source_value packet_a.source_value.rand_mode(1);\t//same with packet_a.randomize(source_value) ret = packet_a.dest_value.rand_mode();   constraint_mode 开关约束。\n1 2 3 4 5 6 7 8 9 10 11  class Packet; rand integer source_value; constraint filter1 { source_value \u0026gt; 2 * m; } endclass function integer toggle_rand( Packet p ); if ( p.filter1.constraint_mode() ) p.filter1.constraint_mode(0); else p.filter1.constraint_mode(1); toggle_rand = p.randomize(); endfunction   ","description":"","id":16,"section":"docs","tags":null,"title":"week8 随机约束","uri":"https://honkw-note.vercel.app/docs/verification/sv/week8/"},{"content":"虚方法  只有虚方法，没有虚函数 虚方法允许父类句柄（指向子类对象）动态调用子类方法 变量命名最好不同，函数命名可以相同（且经常相同），因为有虚方法  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  class BasePacket; int A = 1; int B = 2; function void printA; $display(\u0026#34;BasePacket::A is %d\u0026#34;, A); endfunction : printA virtual function void printB; $display(\u0026#34;BasePacket::B is %d\u0026#34;, B); endfunction : printB endclass : BasePacket class My_Packet extends BasePacket; int A = 3; int B = 4; function void printA; $display(\u0026#34;My_Packet::A is %d\u0026#34;, A); endfunction: printA virtual function void printB; $display(\u0026#34;My_Packet::B is %d\u0026#34;, B); endfunction : printB endclass : My_Packet module tb; BasePacket P1 = new(); My_Packet P2 = new(); initial begin P1.printA; // displays \u0026#39;BasePacket::A is 1\u0026#39;  P1.printB; // displays \u0026#39;BasePacket::B is 2\u0026#39;  P1 = P2; // P1 has a handle to a My_packet object  P1.printA; // displays \u0026#39;BasePacket::A is 1\u0026#39;  P1.printB; // displays \u0026#39;My_Packet::B is 4‘ latest derived method  P2.printA; // displays \u0026#39;My_Packet::A is 3\u0026#39;  P2.printB; // displays \u0026#39;My_Packet::B is 4\u0026#39;  end endmodule   类型转换   static transform - 静态转换\n'int 'real()\n  dynamic transform - 动态转换\n$cast()\n 父类句柄访问子类方法\u0026ndash;\u0026gt; 虚方法 父类句柄访问子类变量\u0026ndash;\u0026gt; 必须将父类句柄转换为子类句柄    ","description":"","id":17,"section":"docs","tags":null,"title":"week9.5 类的多态","uri":"https://honkw-note.vercel.app/docs/verification/sv/week9_5/"},{"content":"thread-线程 begin/end \u0026amp; fork/join\n开辟并行线程的方法只有fork/join\nfork join  fork join fork join_any fork join_none  线程执行流程如下图：\n注意使用wait fork以及disable fork关闭fork join的线程，避免线程常驻后台。\nwait fork等待的是当前begin/end中所有fork/join的线程，并不是最靠近wait fork的线程。\ndisable fork关闭的是当前begin/end中所有fork/join的线程，并不是最靠近disable fork的线程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  `timescale 1ns/1ps module tb; task automatic exec(int id, int t); $display(\u0026#34;@%t exec[%0d] entered\u0026#34;,$time, id); #(t*1ns); $display(\u0026#34;@%t exec[%0d] exited\u0026#34;,$time, id); endtask initial begin exec(1,10); end initial begin exec(2,20); end initial begin exec(3,30); end initial begin exec(4,40); end initial begin exec(5,50); end endmodule module tb2; task automatic exec(int id, int t); $display(\u0026#34;@%t exec[%0d] entered\u0026#34;,$time, id); #(t*1ns); $display(\u0026#34;@%t exec[%0d] exited\u0026#34;,$time, id); endtask initial begin $display(\u0026#34;@%t fork-join_any entered\u0026#34;,$time); fork exec(1,10); exec(2,60); join_any $display(\u0026#34;@%t fork-join_any exited\u0026#34;,$time); $display(\u0026#34;@%t fork-join_none entered\u0026#34;,$time); fork exec(3,30); exec(4,40); join_none $display(\u0026#34;@%t fork-join_none exited\u0026#34;,$time); wait fork; //wait for all fork  //disable fork;  $display(\u0026#34;@%t ini_proc exited\u0026#34;,$time); end initial begin #200ns; end endmodule   time control-时序控制 时序控制放到task中完成\n 延迟控制(delay) #10 事件控制(event)@ 等待控制(wait)wait  event-事件 event 不需要new\n 声明 event 触发 -\u0026gt; 等待 @和wait  @可以等待信号，也可以等待事件。event传递类似句柄传递，不需要用ref。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  module tb; event e1,e2,e3; task automatic wait_event(event e,string name); $display(\u0026#34;@%t start wating event %s\u0026#34;,$time, name); @e; $display(\u0026#34;@%t finish waiting event %s\u0026#34;,$time, name); endtask initial begin fork wait_event(e1,\u0026#34;e1\u0026#34;); wait_event(e2,\u0026#34;e2\u0026#34;); wait_event(e3,\u0026#34;e3\u0026#34;); join end initial begin fork begin #10ns -\u0026gt; e1; end begin #20ns -\u0026gt; e2; end begin #30ns -\u0026gt; e3; end join end endmodule   task无法捕捉参数的变化，需要捕捉添加ref。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  module tb2; //logic e1,e2,e3;  bit e1,e2,e3; //task automatic wait_event(logic e,string name);  task automatic wait_event(ref bit e, input string name); $display(\u0026#34;@%t start wating event %s\u0026#34;,$time, name); @e; $display(\u0026#34;@%t finish waiting event %s\u0026#34;,$time, name); endtask initial begin fork wait_event(e1,\u0026#34;e1\u0026#34;); wait_event(e2,\u0026#34;e2\u0026#34;); wait_event(e3,\u0026#34;e3\u0026#34;); join end initial begin $display(\u0026#34;before fork, e1 = %x\u0026#34;, e1); fork begin #10ns e1 = !e1; end begin #20ns e2 = !e2; end begin #30ns e3 = !e3; end join $display(\u0026#34;after fork, e1 = %x\u0026#34;, e1); end endmodule   @event和wait event @event - 边沿触发。如果同时触发和捕捉可能出现竞争（例如复位时同时触发），应当采用wait\nwait event - 电平触发。\nwait_order 按顺序等待事件。\nwait_order( a, b, c);\nsemaphore-旗语 方法：\n new(N)，分配N把钥匙 get()，try_get() put()，try_put()  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  module tb; semaphore mem_acc_key; int unsigned mem[int unsigned]; task automatic write(int unsigned addr, int unsigned data); mem_acc_key.get(); #1ns; mem[addr] = data; mem_acc_key.put(); endtask task automatic read(int unsigned addr, output int unsigned data); mem_acc_key.get(); #1ns; if(mem.exists(addr)) data = mem[addr] ; else data = \u0026#39;x; mem_acc_key.put(); endtask initial begin int unsigned data = 100; mem_acc_key = new(1); //1 key  forever begin fork begin #10ns; write(\u0026#39;h10,data + 100); $display(\u0026#34;@%t write with data %d\u0026#34;,$time,data); end begin #10ns; read(\u0026#39;h10,data); $display(\u0026#34;@%t read with data %d\u0026#34;,$time,data); end join end end endmodule   mailbox-信箱 mailbox信箱类型等于一个queue队列。\n方法：\n new(int bound = 0) put()，不能放入时会阻塞，try_put()，不能放入时不会阻塞，返回0 get()，获取不到时会阻塞，try_get()，获取不到时不会阻塞，返回0 peek(),try_peek() num()，当前信箱信息的数目  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  module tb; mailbox #(int) mb; initial begin int data; mb = new(8); forever begin case($urandom()%2) 0:begin if(mb.try_put(data))begin data = $urandom_range(0,10); mb.try_put(data); $display(\u0026#34;mb put data %0d\u0026#34;,data); end //if(mb.num()\u0026lt;8)begin  // data = $urandom_range(0,10);  // mb.put(data);  // $display(\u0026#34;mb put data %0d\u0026#34;,data);  //end  end 1:begin if(mb.try_get(data))begin $display(\u0026#34;mb get data %0d\u0026#34;,data); end //if(mb.num()\u0026gt;0)begin  // mb.get(data);  // $display(\u0026#34;mb get data %0d\u0026#34;,data);  //end  end endcase end end endmodule   ","description":"","id":18,"section":"docs","tags":null,"title":"week9 线程同步与通信","uri":"https://honkw-note.vercel.app/docs/verification/sv/week9/"},{"content":"coverage - 覆盖率 code coverage - 代码覆盖率(隐性覆盖率) 仿真工具自动收集。\n  是否需要关心testbench的代码覆盖率？\n一般情况下，不需要。可能在IP验证中需要针对主要的验证代码进行代码覆盖率的验证。\n  toggle coverage - 翻转覆盖率\n  statement/line coverage - 行覆盖率\n  branch coverage - 分支覆盖率\n if (a==1 || b==0)只判断 if为0或者1是否覆盖    condition/expression coverage - 条件/表达式覆盖率()\n if (a==1 || b==0)判断 a和b的所有情况是否覆盖，比分支覆盖率要求更高    fsm coverage - 状态机覆盖率\n  vlog -cover bst \u0026ndash;\u0026gt; ucdb文件 \u0026mdash;\u0026gt; 看coverage报告\nfunction coverage - 功能覆盖率(显性覆盖率) covergroup- 覆盖组 一个类可以声明多个covergroup,一个covergroup可以定义多个coverpoint，可以包含以下内容：\n 覆盖点（coverpoint） 选项（option） 形式参数（argument） 可选触发（trigger event）  覆盖组可以定义在类里，也可以定义在模块或者程序（program）中。\n覆盖组可以采集任何可见的变量，比如程序或模块变量、接口信号或者设计中的任何信号。在类中的覆盖组也可以采集类的成员变量。\n1 2 3 4 5 6 7 8 9  enum { red, green, blue } color; bit [3:0] pixel_adr, pixel_offset, pixel_hue; covergroup g2 @(posedge clk); Hue: coverpoint pixel_hue; Offset: coverpoint pixel_offset; AxC: cross color, pixel_adr; // cross 2 variables  all: cross color, Hue, Offset; // cross 1 VARs and 2 CPs endgroup g2 cg_inst = new();    coverpoint可以添加名称，也可以不添加(仿真器自动命名)： 只需要例化一次，则可以直接new() covergroup的名字，不需要单独声明句柄。  1 2 3 4 5 6 7 8 9 10  class xyz; bit [3:0] m_x; int m_y; bit m_z; covergroup cov1 @m_z; // embedded covergroup  coverpoint m_x; coverpoint m_y; endgroup function new(); cov1 = new; endfunction endclass   bin - 仓 一个coverpoint可以对应多个bin（仓），这些仓可以显性指定，也可以隐性指定\n1 2 3 4 5 6 7 8 9 10  bit [9:0] v_a; covergroup cg @(posedge clk); coverpoint v_a { bins a = { [0:63],65 };\t//single bin  bins b[] = { [127:150],[148:191] };\t//multiple bin, where [127:150]\u0026amp;[148:191] has same cnt  bins c[] = { 200,201,202 };\t//3 bin  bins d = { [1000:$] };\t//several bin  bins others[] = default; } endgroup   with 在定义bin时，可以使用with来进一步限定其关心的数值，with可以用表达式或者函数来衡量\n1 2 3 4 5 6  a: coverpoint x { bins mod3[] = {[0:255]} with (item % 3 == 0); } coverpoint b { bins func[] = b with (myfunc(item)); }   覆盖数值的变化 除了可以覆盖数值，还可以覆盖数值的变化。（简单的通过这个做，复杂的通过断言，sequece等做）\n1 2 3 4 5 6 7 8 9 10 11 12 13  //range_list1 =\u0026gt; range_list2 1,5 =\u0026gt; 6, 7 //trans_item [* repeat_range ] 3 [* 5]\t//表示3=\u0026gt;3=\u0026gt;3=\u0026gt;3=\u0026gt;3 3 [* 3:5]\t//表示( 3=\u0026gt;3=\u0026gt;3 ), ( 3=\u0026gt;3=\u0026gt;3=\u0026gt;3 )或( 3=\u0026gt;3=\u0026gt;3=\u0026gt;3=\u0026gt;3 )  3 [-\u0026gt; 3]\t//表示...=\u0026gt;3...=\u0026gt;3...=\u0026gt;3 //在=\u0026gt;序列后的下一个时序必须紧跟=\u0026gt;序列的最后一个事件 1 =\u0026gt; 3 [ -\u0026gt; 3] =\u0026gt; 5\t//表示1...=\u0026gt;3...=\u0026gt;3...=\u0026gt;3 =\u0026gt;5  3 [= 2]\t//表示...=\u0026gt;3...=\u0026gt;3 //跟随-\u0026gt;序列的下一次值变化可以发生在-\u0026gt;结束后的任何时刻。 1 =\u0026gt; 3 [=2] =\u0026gt; 6\t//表示1...=\u0026gt;3...=\u0026gt;3...=\u0026gt;6   1 2 3 4 5 6 7 8  bit [4:1] v_a; covergroup cg @(posedge clk); coverpoint v_a { bins sa = (4 =\u0026gt; 5 =\u0026gt; 6), ([7:9],10=\u0026gt;11,12); bins sb[] = (4=\u0026gt; 5 =\u0026gt; 6), ([7:9],10=\u0026gt;11,12); bins sc = (12 =\u0026gt; 3 [-\u0026gt; 1]); } endgroup   bin的大小 如果变量是整形（M位宽），那么bin的类型将是2^M和auto_bin_max（默认32）选项的较小值。\nwildcard 1  wildcard bins g12_15 = { 4\u0026#39;b11?? };\t//g12_15可以用来表示12到15之间的值，即1100, 1101, 1110, 1111   ignore_bins 用来将其排除在有效统计的bin集合之外。\n1 2 3 4 5 6  covergroup cg23; coverpoint a { ignore_bins ignore_vals = {7,8}; ignore_bins ignore_trans = (1=\u0026gt;3=\u0026gt;5); } endgroup   illegal_bins 用来指出采样到的数值为非法制，如果illegal_bins被采样到，那么仿真将报错\n1 2 3 4 5 6  covergroup cg3; coverpoint b { illegal_bins bad_vals = {1,2,3}; illegal_bins bad_trans = (4=\u0026gt;5=\u0026gt;6); } endgroup   参数传递 可以传递参数，注意covergroup用于采样，一般只有input和ref\n1 2 3 4 5 6 7 8 9 10 11  covergroup cg (ref int ra, input int low, int high ) @(posedge clk); coverpoint r { bins good = { [low : high] }; bins bad[] = default; } endgroup ... int va, vb; cg c1 = new( va, 0, 50 ); cg c2 = new( vb, 120, 600 );   禁止采样 可以通过iff在一些情况下禁止coverpoint的采集\n1 2 3  covergroup g4; coverpoint s0 iff(!reset); endgroup   cross - 交叉覆盖率 covergroup可以在两个或者更多的coverpoint或者变量之间定义交叉覆盖率（cross coverage）\n1 2 3 4 5 6 7 8 9  int i,j; covergroup ct; coverpoint i { bins i[] = { [0:1] }; } coverpoint j { bins j[] = { [0:1] }; } x1: cross i,j; x2: cross i,j { bins i_zero = binsof(i) intersect { 0 }; } endgroup   cross X1有以下自动分配的bin\n1  \u0026lt;i[0],j[0]\u0026gt; \u0026lt;i[1],j[0]\u0026gt; \u0026lt;i[0],j[1]\u0026gt; \u0026lt;i[1],j[1]\u0026gt;   cross X1有以下自定义的bin\n1 2 3  \u0026lt;i[0],j[0]\u0026gt; \u0026lt;i[0],j[1]\u0026gt; // 自定义i_zero bin \u0026lt;i[1],j[0]\u0026gt; // 保留该自动生成bin \u0026lt;i[1],j[1]\u0026gt; // 保留该自动生成bin   需要初学者注意的是，即便自己为cross定义了bin，但是系统仍然会自动生成bin，自动生成bin的原则是，只要该bin不在自定义bin的范围，那么就仍然会保留。\noption - 覆盖率选项 covergroup的选项\n name，命名 weight，比重 goal，目标一般为100% comment，注释 at_least auto_bin_max，自动bin的大小 per_instance，例化多个covergroup  方法\n","description":"","id":19,"section":"docs","tags":null,"title":"week10 覆盖率","uri":"https://honkw-note.vercel.app/docs/verification/sv/week10/"},{"content":"代码debug问题   此代码有一项检查肯定没做，就是recv应当检测valid拉低前一个时钟周期为高，否则不符合时序。此代码均略过了这一个周期。\n  do while 循环的结构比较怪异\n参考[SV]do while循环使用案例总结_元直数字电路验证的博客-CSDN博客_sv while\n1 2 3  do begin ... end while(condition);     for循环可以直接跳过不需要的cycle，只要有valid信号判断在\n  if/else长了一定要写begin/end，或者缩进，不然逻辑关系看不清\n  注意return(0);的写法\n  $sformatf用法\n参考：UVM之sformat - liheng369 - 博客园\n  实验课堂问题   为什么packet的payload是按8bit进行的？假如连续发送的不是按byte，比如输入激励为发12bit * 2 的方式，能否正常接收？\n  为了方便操作？这个确实没明白\n  可以，根据测试，按任意多位的bit应该都是可以的\n    使用fork..join的任务send()和recv()为什么一定会退出？\n对于send()，其操作按clocking block的@rtr_io.cb操作，因此发送的周期保证有限，一定会退出。\n对于recv()\n  其操作虽然有等待 @(negedge rtr_io.cb.frameo_n[da])，但外置了watchdog，有超时机制;\n  后面的操作虽然有forever，但是在for循环内到最后一个bit会return退出任务，因此forever不会一直执行。当然这里有个前提是rtr_io.cb.frameo_n[da]拉低后一定能拉起来，不然forever确实应该会卡死。（即等到了拉低却没等到拉高）\n    如何修改写法？\n原写法：\n1  for(int i=0; i\u0026lt;8; i=i)   改写为：\n1  for(int i=0; i\u0026lt;8; i=i+1)   需要提前等一个周期的valid到来，且后面循环的的等待也要提前。\n参考：Study/verification/v0/lab3 - HonkW\u0026rsquo;s Onedrive\n  ref和inout的使用差别?\n传递标量时无区别，传递存储类型时存在问题（参考绿皮书）\n  static int？\n之前学习过类中的静态变量，其变量实际属于类本身，而不属于对象。\n任务task中的静态变量其实也是对应automatic的，可以在多次进入同一个任务时使变量保持静态。（其实也对应了，类本身是automatic的）\n  payload和pkt2cmp_payload严格比对？\n严格来说，不应该比对我们的生成的原始数据和接收的数据，而是应该通过monitor监视发送的数据和接收的数据并比对。\n  并行的发送和接收数据？设计能够完成接收吗？两个通道同时发送给同一个通道？\n实验四五之后回答。\n  实验指导问题   sv_seed?\n默认即为-sv_seed 0，如果想每次仿真随机数据不同，则使用-sv_seed random，否则使用同一个sv_seed伪随机化的数据是相同的。\n  ","description":"","id":20,"section":"docs","tags":null,"title":"Lab3","uri":"https://honkw-note.vercel.app/docs/verification/sv/lab3/"},{"content":"Git使用问题 Failed to connect to github.com port 443: Timed out Failed to connect to github.com port 443: Timed out - quanzhan - 博客园\n 主要原因是使用了代理。按照代理的端口改一下下面的配置即可（假设你代理端口为1080）。\n git config --global http.proxy http://127.0.0.1:1080 git config --global https.proxy http://127.0.0.1:1080 ","description":"","id":21,"section":"docs","tags":null,"title":"git","uri":"https://honkw-note.vercel.app/docs/git/git/"},{"content":"参考Wenhui\u0026rsquo;s Rotten Pen\n","description":"","id":22,"section":"","tags":null,"title":"About","uri":"https://honkw-note.vercel.app/about/"}]